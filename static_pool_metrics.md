# üè¶ Static Pool Data
| id | Feature | Description | Derivation | Type | Source |
|----|----------|--------------|-------------|------|--------|
| 1 | pool_address | Address/Id of the liquidity pool (if any) | Pool address | String | Graph |
| 2 | chain_name | Blockchain (e.g. Ethereum, Solana) | Chain name | String | CSV |
| 3 | chain_id | Numeric or symbolic chain identifier | Chain id | Integer/String | CSV |
| 4 | token0_address | Address of first token in pair | Token address | String | CSV, Graph |
| 5 | token1_address | Address of second token in pair | Token address | String | CSV, Graph |
| 6 | token0_pool_amount | Amount of pools on DEX with first token | Count fetched pools | Integer | Graph |
| 7 | token1_pool_amount | Amount of pools on DEX with second token | Count fetched pools | Integer | Graph |
| 8 | token0_age_minutes | Time from first token contract creation to DEX listing | Get pool creation timestamp from The Graph, get token contract creation timestamp from Etherscan getcontractcreation (includes timestamp), calculate difference in minutes | Integer (minutes) | Etherscan, Graph |
| 9 | token1_age_minutes | Time from second token contract creation to DEX listing | Get pool creation timestamp from The Graph, get token contract creation timestamp from Etherscan getcontractcreation (includes timestamp), calculate difference in minutes | Integer (minutes) | Etherscan, Graph |
| 10 | first_pool_activity_time | Time from DEX listing to first pool LP action | Query Dune with single aggregated SQL query of Mint action, filtered by pool addresses | Integer (minutes) | Dune, Flipside |
| 11 | dex_name | Name of DEX where pool is created | DEX name | String | CSV |
| 12 | token0_max_supply | Maximum supply defined in first token contract | Use batched eth_call of totalSupply() at your target block. The fastest way is a Multicall at that block; fall back to direct calls if the multicall contract didn't exist yet at that block. | Float | RPC |
| 13 | token1_max_supply | Maximum supply defined in second token contract | Use batched eth_call of totalSupply() at your target block. The fastest way is a Multicall at that block; fall back to direct calls if the multicall contract didn't exist yet at that block. | Float | RPC |
| 14 | token0_minting_enabled | Can the first token be minted after deployment? | Check if there is a value in default proxy slot, if yes then fetch bytecode from RPC for this value, if no fetch bytecode from RPC for original address, execute bytecode with mythril, look in execution graph for pattern that corresponds to mint function | Boolean | RPC, Mythril |
| 15 | token1_minting_enabled | Can the second token be minted after deployment? | Check if there is a value in default proxy slot, if yes then fetch bytecode from RPC for this value, if no fetch bytecode from RPC for original address, execute bytecode with mythril, look in execution graph for pattern that corresponds to mint function | Boolean | RPC, Mythril |
| 16 | token0_verified_contract | Is the first token contract verified on-chain? | Call Etherscan getsourcecode endpoint for proxy and for implementation | Boolean | Etherscan |
| 17 | token1_verified_contract | Is the second token contract verified on-chain? | Call Etherscan getsourcecode endpoint for proxy and for implementation | Boolean | Etherscan |
| 18 | token0_ownership_renounced | Is ownership of the first token contract renounced? | Use batched eth_call of owner() function. The fastest way is a Multicall at that block; fall back to direct calls if the multicall contract didn't exist yet at that block. | Boolean | RPC |
| 19 | token1_ownership_renounced | Is ownership of the second token contract renounced? | Use batched eth_call of owner() function. The fastest way is a Multicall at that block; fall back to direct calls if the multicall contract didn't exist yet at that block. | Boolean | RPC |
| 20 | token0_proxy | Whether the first token uses a proxy | Call Etherscan getsourcecode endpoint, check if Proxy field equals '1' | Boolean | Etherscan |
| 21 | token0_pausable | If the first token has pausable functionality | Check if there is a value in default proxy slot, if yes then fetch bytecode from RPC for this value, if no fetch bytecode from RPC for original address, execute bytecode with mythril, look in execution graph for pattern that corresponds to pause function (OZ Pausable) | Boolean | RPC, Mythril |
| 22 | token0_burning_enabled | Can the first token be burned after deployment? | Check if there is a value in default proxy slot, if yes then fetch bytecode from RPC for this value, if no fetch bytecode from RPC for original address, execute bytecode with mythril, look in execution graph for pattern that corresponds to burn function | Boolean | RPC, Mythril |
| 23 | token1_proxy | Whether the second token uses a proxy | Call Etherscan getsourcecode endpoint, check if Proxy field equals '1' | Boolean | Etherscan |
| 24 | token1_pausable | If the second token has pausable functionality | Check if there is a value in default proxy slot, if yes then fetch bytecode from RPC for this value, if no fetch bytecode from RPC for original address, execute bytecode with mythril, look in execution graph for pattern that corresponds to pause function (OZ Pausable) | Boolean | RPC, Mythril |
| 25 | token1_burning_enabled | Can the second token be burned after deployment? | Check if there is a value in default proxy slot, if yes then fetch bytecode from RPC for this value, if no fetch bytecode from RPC for original address, execute bytecode with mythril, look in execution graph for pattern that corresponds to burn function | Boolean | RPC, Mythril |
| 26 | token0_owner_is_contract | Is the first token owner address a contract? | Call getCode on token owner address; if it returns non-empty bytecode, it's a contract | Boolean | RPC |
| 27 | token1_owner_is_contract | Is the second token owner address a contract? | Call getCode on token owner address; if it returns non-empty bytecode, it's a contract | Boolean | RPC |
| 28 | pool_deployer_is_contract | Is the pool deployer address a contract? | Call getCode on deployer address; if it returns non-empty bytecode, it's a contract | Boolean | RPC |
| 29 | token0_owner_tx_count | Amount of transactions from the owner address | If owner address is the contract (getCode returns not 0) then call Etherscan account txlist API to count transactions to the contract, otherwise call eth_getTransactionCount | Integer | Etherscan, RPC |
| 30 | token1_owner_tx_count | Amount of transactions from the owner address | If owner address is the contract (getCode returns not 0) then call Etherscan account txlist API to count transactions to the contract, otherwise call eth_getTransactionCount | Integer | Etherscan, RPC |
| 31 | pool_deployer_tx_count | Amount of transactions from the pool deployer address | If deployer address is the contract (getCode returns not 0) then call Etherscan account txlist API to count transactions to the contract, otherwise call eth_getTransactionCount | Integer | Etherscan, RPC |
| 32 | token0_owner_age | Time passed from first token owner address's first tx | If owner address is the contract (getCode returns not 0) then call Etherscan getcontractcreation, otherwise call Etherscan account txlist API with offset=1 and sort=asc to get first transaction directly | Integer (minutes) | Etherscan |
| 33 | token1_owner_age | Time passed from second token owner address's first tx | If owner address is the contract (getCode returns not 0) then call Etherscan getcontractcreation, otherwise call Etherscan account txlist API with offset=1 and sort=asc to get first transaction directly | Integer (minutes) | Etherscan |
| 34 | pool_deployer_age | Time passed from pool deployer address's first tx | If deployer address is the contract (getCode returns not 0) then call Etherscan getcontractcreation, otherwise call Etherscan account txlist API with offset=1 and sort=asc to get first transaction directly | Integer (minutes) | Etherscan |
| 35 | token0_owner_gas_burnt | Amount of gas burnt by first token owner address | Call Etherscan account txlist API to get all transactions, sum gasUsed for total gas units consumed | Integer | Etherscan |
| 36 | token1_owner_gas_burnt | Amount of gas burnt by second token owner address | Call Etherscan account txlist API to get all transactions, sum gasUsed for total gas units consumed | Integer | Etherscan |
| 37 | pool_deployer_gas_burnt | Amount of gas burnt by pool deployer address | Call Etherscan account txlist API to get all transactions, sum gasUsed for total gas units consumed | Integer | Etherscan |
| 38 | token0_top_10_holders_percent | Supply of first token owned by top 10 holders in percent | Calculate percent of summed top 10 holders supply at the moment of pool creation | Float (%) | Bitquery |
| 39 | token1_top_10_holders_percent | Supply of second token owned by top 10 holders in percent | Calculate percent of summed top 10 holders supply at the moment of pool creation | Float (%) | Bitquery |
| 40 | token0_num_holder_launch | Number of first token holders at the moment of pool creation | Count holders at the moment pool is created | Integer | Bitquery |
| 41 | token1_num_holder_launch | Number of second token holders at the moment of pool creation | Count holders at the moment pool is created | Integer | Bitquery |
| 42 | token0_liquidity_depth | Percent of first token total supply locked in pool | Call token contract balanceOf(poolAddress) at pool creation block, divide by token totalSupply() at same block, multiply by 100 for percentage | Float (%) | RPC |
| 43 | token1_liquidity_depth | Percent of second token total supply locked in pool | Call token contract balanceOf(poolAddress) at pool creation block, divide by token totalSupply() at same block, multiply by 100 for percentage | Float (%) | RPC |
| 44 | label | Whether pool contains fraud asset | True if one token is labeled as scam, false if both are trustworthy (labeled or in list on https://tokens.uniswap.org/), undefined otherwise | Boolean | CSV |
